plugins {
    id 'jacoco'
    id 'java-library'
    id 'maven-publish'
    id 'com.jfrog.bintray' version '1.7.3'
    id 'com.github.kt3k.coveralls' version '2.5.0-x'
}

String.metaClass.bash = { ->
    ProcessBuilder processBuilder = new ProcessBuilder('bash', '-c', delegate.toString())
    processBuilder.redirectErrorStream(true)

    Process process = processBuilder.start()
    process.getOutputStream().close()

    try {
        process.waitForOrKill(10_000)
        def output = process.text
        return output ? output : ''
    } catch (IOException | InterruptedException ignore) {
        return ''
    }
}

dependencies {
    implementation 'com.squareup.okio:okio:1.14.0'
    implementation 'com.squareup.okhttp3:okhttp:3.10.0'
    implementation 'com.google.code.gson:gson:2.8.4'

    testImplementation 'junit:junit:4.12'
    testImplementation 'org.mockito:mockito-core:2.23.0'
    testImplementation 'org.assertj:assertj-core:3.9.0'
}

group 'com.echsylon.atlantis'
version prepareVersionName()

repositories {
    jcenter()
}

jar {
    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version)
    }
}

jacoco {
    reportsDir = file("${buildDir}/reports/")
}

publishing {
    publications {
        atlantis(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact javadocJar
        }
    }
}

bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_KEY')
    publications = ['atlantis']
    publish = true

    pkg {
        repo = 'maven'
        name = 'atlantis'
        licenses = ['Apache-2.0']
        websiteUrl = 'https://github.com/echsylon/atlantis/wiki'
        issueTrackerUrl = 'https://github.com/echsylon/atlantis/issues'
        vcsUrl = 'https://github.com/echsylon/atlantis.git'
        githubRepo = 'echsylon/atlantis'

        version {
            name = rootProject.version
            vcsTag = "v${rootProject.version}"
            released = new Date()
        }
    }
}

coveralls {
    jacocoReportPath = "${buildDir}/reports/coverage/coverage.xml"
}

task('sourcesJar', type: Jar) {
    from sourceSets.main.allJava
    classifier = 'sources'
}

task('javadocJar', type: Jar) {
    from javadoc
    classifier = 'javadoc'
}

task('coverage', type: JacocoReport) {
    group = "Reporting"
    sourceSets sourceSets.main
    classDirectories = files("${buildDir}/classes")
    sourceDirectories = files("${projectDir}/src/main/java")
    executionData = files("${buildDir}/jacoco/test.exec")
    reports {
        csv.enabled = false
        xml.enabled = true
        html.enabled = true
    }

}

task('prepareMajorRelease', dependsOn: 'test') {
    doLast {
        def version = getVersionFromLatestTag()
        def (major, minor, patch, build) = version.tokenize()
        def nextMajor = (major.toInteger() + 1).toString()
        def newVersionName = "${nextMajor}.0.0"
        def oldVersionName = getLatestReleaseTagName()
        createNewTag(oldVersionName, newVersionName, nextMajor, '0', '0', build)
    }
}

task('prepareMinorRelease', dependsOn: 'test') {
    doLast {
        def version = getVersionFromLatestTag()
        def (major, minor, patch, build) = version.tokenize()
        def nextMinor = (minor.toInteger() + 1).toString()
        def newVersionName = "${major}.${nextMinor}.0"
        def oldVersionName = getLatestReleaseTagName()
        createNewTag(oldVersionName, newVersionName, major, nextMinor, "0", build)
    }
}

task('preparePatchRelease', dependsOn: 'test') {
    doLast {
        def version = getVersionFromLatestTag()
        def (major, minor, patch, build) = version.tokenize()
        def nextPatch = (patch.toInteger() + 1).toString()
        def newVersionName = "${major}.${minor}.${nextPatch}"
        def oldVersionName = getLatestReleaseTagName()
        createNewTag(oldVersionName, newVersionName, major, minor, nextPatch, build)
    }
}

task('prepareSnapshotRelease', dependsOn: 'test') {
    doLast {
        def version = getVersionFromLatestTag()
        def (major, minor, patch, build) = version.tokenize()
        def nextBuild = (build.toInteger() + 1).toString()
        def newVersionName = "${major}.${minor}.${patch}-${nextBuild}-SNAPSHOT"
        def oldVersionName = getLatestReleaseTagName()
        createNewTag(oldVersionName, newVersionName, major, minor, patch, nextBuild)
    }
}

task('updateRemoteJavaDoc', dependsOn: 'javadoc') {
    doLast {
        "git add docs".bash()
        "git commit --message 'javadoc'".bash()
        "git subtree split --prefix docs -b gh-pages".bash()
        "git push -f origin gh-pages:gh-pages".bash()
        "git branch -D gh-pages".bash()
        "git reset HEAD~1 --hard".bash()
    }
}

private static def prepareVersionName() {
    def version = getVersionFromLatestTag()
    def (major, minor, patch, build) = version.tokenize()
    def versionName = "${major}.${minor}.${patch}"
    println(versionName)
    return versionName
}

private static def getLatestReleaseTagName() {
    // Fetch all tags from remote
    "git fetch origin 'refs/tags/*:refs/tags/*'".bash()

    // Get the latest tag that looks something like "v1.2.3".
    // --count=1 is for getting one match
    // --sort=-taggerdate is for sorting on descending (the '-') tag created date
    // 'refs/tags/...' is the pattern of the tag name to match
    return "git for-each-ref --count=1 --sort=-taggerdate --format='%(tag)' 'refs/tags/v[0-9]*.[0-9]*.[0-9]*'".bash().trim()
}

private static def getVersionFromLatestTag() {
    // Fetch all tags from remote
    "git fetch origin 'refs/tags/*:refs/tags/*'".bash()

    // Get the subject line from the latest version tag
    def tag = "git for-each-ref --count=1 --sort=-taggerdate --format='%(subject)' 'refs/tags/v[0-9]*.[0-9]*.[0-9]*'".bash()

    // "Version x.y.z (n)"
    def filter = "s/Version\\s\\([0-9]\\{1,\\}\\).\\([0-9]\\{1,\\}\\).\\([0-9]\\{1,\\}\\)\\(.*\\)/\\1 \\2 \\3 \\4/p"

    // "x y z"  and maybe "(n)"
    // NOTE! This is GNU sed. On mac do `brew install gnu-sed --with-default-names` to get it working.
    def version = "echo '${tag}' | sed -n '${filter}'".bash().trim()
    def segments = version.tokenize()

    if (segments.isEmpty())
        return '0 0 0 0'

    if (segments.size() == 3)
        return version + ' 0'

    if (segments.size() == 4) {
        segments[3] = segments[3].replaceAll("[^\\d]", "")
        return segments.join(" ")
    }

    throw new IllegalArgumentException("Unexpected version format in tag: ${tag}")
}

private static def createNewTag(oldVersionName, newVersionName, major, minor, patch, build) {
    def body = "git log --pretty=format:'* %s' ${oldVersionName}..HEAD".bash()
    "git tag -a v${newVersionName} -m \"Version ${major}.${minor}.${patch} (${build})\n\n${body}\"".bash()
    presentResult(newVersionName)
}

private static def presentResult(versionName) {
    println("\nYou can now:")
    println("  (s)how   - git show v${versionName}")
    println("  (d)elete - git tag -d v${versionName}")
    println("  (p)ush   - git push && git push --tags")
    println("  (q)uit   - quit")
    println("\nTo edit a tag you\'ll have to manually do:")
    println('      git tag -a -f ${version}\n ')

    handleUserInput(versionName)
}

private static def handleUserInput(versionName) {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in))
    def choice = br.readLine()

    switch (choice) {
        case "s":
        case "show":
            println("git show v${versionName}".bash())
            break
        case "d":
        case "delete":
            println("git tag -d v${versionName}".bash())
            break
        case "p":
        case "push":
            println("git push && git push --tags".bash())
            break
        case "q":
        case "quit":
            // Just close your eyes and let it happen
            break
        default:
            println('\nHuh?!')
            handleUserInput(versionName)
            break
    }

}

tasks['assemble'].dependsOn tasks['sourcesJar'], tasks['javadocJar']
tasks['coveralls'].dependsOn tasks['coverage']
